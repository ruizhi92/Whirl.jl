<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Time marching · Whirl.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Whirl.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="fields.html">Fields</a></li><li><a class="toctext" href="bodies.html">Bodies</a></li><li><a class="toctext" href="saddlesystems.html">Saddle point systems</a></li><li class="current"><a class="toctext" href="timemarching.html">Time marching</a><ul class="internal"><li><a class="toctext" href="#Integrating-factor-systems-1">Integrating factor systems</a></li><li><a class="toctext" href="#Constrained-systems-1">Constrained systems</a></li><li><a class="toctext" href="#Constrained-integrating-factor-systems-1">Constrained integrating factor systems</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="timemarching.html">Time marching</a></li></ul><a class="edit-page" href="https://github.com/jdeldre/Whirl.jl/blob/master/docs/src/manual/timemarching.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Time marching</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Time-marching-1" href="#Time-marching-1">Time marching</a></h1><div>\[\def\ddt#1{\frac{\mathrm{d}#1}{\mathrm{d}t}}

\renewcommand{\vec}{\boldsymbol}
\newcommand{\uvec}[1]{\vec{\hat{#1}}}
\newcommand{\utangent}{\uvec{\tau}}
\newcommand{\unormal}{\uvec{n}}

\renewcommand{\d}{\,\mathrm{d}}\]</div><div></div><p><code>whirl</code> is equipped with a few classes of time marching schemes for advancing time-dependent equations.</p><h2><a class="nav-anchor" id="Integrating-factor-systems-1" href="#Integrating-factor-systems-1">Integrating factor systems</a></h2><p>Integrating factor systems that we encounter in <code>whirl</code> are of the form</p><div>\[\ddt u = A u + r_1(u,t), \quad u(0) = u_0\]</div><p>The operator <span>$A$</span> may be a matrix or a scalar, but is generally independent of time. (The   method of integrating factors can deal with time-dependent <span>$A$</span>, but we don&#39;t encounter   such systems in the <code>whirl</code> context so we won&#39;t discuss them.) For this purpose, we use the <code>IFRK</code> class of solver, which stands for Integrating Factor Runge-Kutta. This method solves   the part associated with <span>$A$</span> exactly, via the integrating factor, and advances a modified   equation by Runge-Kutta method to account for the remaining part <span>$f$</span>.</p><p>We discussed the construction   of the integrating factor in the context of fields in <a href="fields.html#Fields-1">Fields</a>. But first, let&#39;s   give an example of how we can solve a simpler problem with just a single scalar-valued   <span>$u$</span>. The example we will solve is</p><div>\[\ddt u = -\alpha u + \cos(\omega t),\quad u(0) = u_0\]</div><p>The exact solution is easily obtained:</p><div>\[u(t) = u_0 e^{-\alpha t} + \frac{1}{\alpha^2+\omega^2} \left[ \alpha(\cos(\omega t) - e^{-\alpha t}) + \omega \sin (\omega t)\right]\]</div><p>Let&#39;s solve it numerically, so we can evaluate the accuracy of the solver. We should note that the integrating factor for this system is <span>$e^{-\alpha t}$</span>.</p><p>For demonstration, we will set <span>$\alpha = 1$</span>, <span>$\omega = 4$</span>, and <span>$u_0 = 1$</span>.</p><div></div><pre><code class="language-julia-repl">julia&gt; α = 1; ω = 4; u₀ = 1.0;</code></pre><p>Here is the exact solution for later comparison</p><pre><code class="language-julia-repl">julia&gt; uex(t) = u₀*exp(-α*t) + (α*(cos(ω*t)-exp(-α*t))+ω*sin(ω*t))/(α^2+ω^2)
uex (generic function with 1 method)</code></pre><p>The first steps are to define operators that provide the integrating factor and the right-hand side of the equations. For the integrating factor, we extend the definition of <a href="fields.html#Whirl.Fields.plan_intfact"><code>plan_intfact</code></a> from <a href="fields.html#Fields-1">Fields</a>.</p><pre><code class="language-julia-repl">julia&gt; Whirl.plan_intfact(t::Float64,u::Vector{Float64}) = exp(-α*t);</code></pre><p>Note that we have defined this extended form of <code>plan_intfact</code> to adhere to the standard form, accepting arguments for time <code>t</code> and the state vector <code>u</code>, even though the state vector isn&#39;t strictly needed here. The state &#39;vector&#39; in this problem is actually only a scalar, of course. But the time marching method does not accept scalar-type states currently, so we will make <code>u</code> a 1-element vector to use the <code>whirl</code> tools.</p><p>Now let us define the right-hand side function. This function should also adhere to the standard form, which requires the state vector <code>u</code> and the time <code>t</code> as arguments.</p><pre><code class="language-julia-repl">julia&gt; r₁(u::Vector{Float64},t::Float64) = cos(ω*t);</code></pre><p>We also need to set the time-step size (<span>$0.01$</span>) and the initial condition. For the latter, we set up the state vector as a 1-element vector, as discussed earlier:</p><pre><code class="language-julia-repl">julia&gt; Δt = 0.01;

julia&gt; u = [u₀];</code></pre><p>We can now construct the integrator. We supply a form of the state vector (for use as a template   for pre-allocating space for internal storage variables), the time-step size, and the   definitions of the integrating factor and the right-hand side function:</p><pre><code class="language-julia-repl">julia&gt; ifrk = IFRK(u,Δt,plan_intfact,r₁,rk=TimeMarching.RK31)
Order-3 IF-RK integator with
   State of type Array{Float64,1}
   Time step size 0.01</code></pre><p>We have set the time step size to <span>$0.01$</span>. We have also specified that the Runge-Kutta method to be used is a third-order method, <code>RK31</code>, specially designed for storing as few different versions of the integrating factor as necessary. This is actually the default method, so we could have omitted this keyword argument. There are other choices, as well, such as <code>TimeMarching.Euler</code> for the forward Euler method.</p><p>Now we can solve the system. The integrator has a simple form, accepting as arguments the current time and state, and returning the updated versions of these at the end of the step. We place this integrator inside of a loop and store the results. (Since <code>u</code> is set up   as a 1-element vector, then we will store only the element of this vector.)</p><pre><code class="language-julia-repl">julia&gt; uhist = Float64[]; # for storing the solution

julia&gt; T = 0:Δt:10;

julia&gt; for t in T
         push!(uhist,u[1]) # storage
         t, u = ifrk(t,u) # advancement by one step by the integrator
       end</code></pre><p>Now we can plot the result and compare it with the exact solution.</p><pre><code class="language-julia-repl">julia&gt; plot(T,uhist,label=&quot;numerical&quot;,xlabel=&quot;t&quot;,ylabel=&quot;u(t)&quot;)
Plot{Plots.PyPlotBackend() n=1}

julia&gt; plot!(T,uex.(T),label=&quot;exact soln&quot;)
Plot{Plots.PyPlotBackend() n=2}</code></pre><p><img src="ifrk.svg" alt/></p><p>As we can see, the results are nearly indistinguishable.</p><h2><a class="nav-anchor" id="Constrained-systems-1" href="#Constrained-systems-1">Constrained systems</a></h2><h2><a class="nav-anchor" id="Constrained-integrating-factor-systems-1" href="#Constrained-integrating-factor-systems-1">Constrained integrating factor systems</a></h2><p>Constrained integrating factor systems that we encounter in <code>whirl</code> are of the form</p><div>\[\ddt u = A u - B_1^T f + r_1(u,t), \quad B_2 u = r_2(u,t), \quad u(0) = u_0\]</div><p>where <span>$f$</span> is again the Lagrange multiplier for enforcing the constraints on <span>$u$</span>. Now, we combine the ideas of the last two sections into a single integrator.</p><p>Let&#39;s demonstrate this on the example of heat diffusion from a circular ring whose temperature is held constant. In this case, <span>$A$</span> is the discrete Laplace operator, <span>$L$</span>, times the heat diffusivity, <span>$r_1$</span> is zero (in the absence of volumetric heating sources), and <span>$r_2$</span> is the temperature of the ring. The operators <span>$B_1^T$</span> and <span>$B_2$</span> will be the regularization and interpolation operators between discrete point-wise data on the ring and the field data.</p><p>The ring will have radius <span>$1/2$</span> and fixed temperature <span>$1$</span>, and the heat diffusivity is <span>$1$</span>. (In other words, the problem has been non-dimensionalized by the diameter of the circle, the dimensional ring temperature, and the dimensional diffusivity.)</p><p>First, we will construct a field to accept the temperature on</p><pre><code class="language-julia-repl">julia&gt; nx = 129; ny = 129; Lx = 2.0; Δx = Lx/(nx-2);

julia&gt; u₀ = Nodes(Dual,(nx,ny)); # field initial condition</code></pre><p>Now set up a ring of points on the circle at center <span>$(1,1)$</span>.</p><pre><code class="language-julia-repl">julia&gt; n = 128; θ = linspace(0,2π,n+1);

julia&gt; R = 0.5; xb = 1.0 + R*cos.(θ); yb = 1.0 + R*sin.(θ);

julia&gt; X = VectorData(xb[1:n],yb[1:n]);

julia&gt; f = ScalarData(X); # to be used as the Lagrange multiplier</code></pre><p>From this, construct the regularization and interpolation operators in their usual symmetric form:</p><pre><code class="language-julia-repl">julia&gt; reg = Regularize(X,Δx;issymmetric=true)
Symmetric regularization/interpolation operator with non-filtered interpolation
  128 points in grid with cell area 0.000248

julia&gt; Hmat, Emat = RegularizationMatrix(reg,f,u₀);</code></pre><p>Now set up the right-hand side operators. Both must take the standard form, with arguments of the types of <code>u</code> and <code>t</code>. For <span>$r_1$</span>, we will simply set it to a field of zeros in the same type as <code>u</code>. For <span>$r_2$</span>, we set the result uniformly to <span>$1$</span>.</p><pre><code class="language-julia-repl">julia&gt; r₁(u::Nodes{T,NX,NY},t::Float64) where {T,NX,NY} = Nodes(T,u); # sets to zeros

julia&gt; r₂(u::Nodes{T,NX,NY},t::Float64) where {T,NX,NY} = 1.0; # sets uniformly to 1.0</code></pre><p>We will set the time-step size to a large value (<span>$1.0$</span>) for demonstration purposes. The method remains stable for any choice. We also initialize time <code>t</code> and the state <code>u</code>:</p><pre><code class="language-julia-repl">julia&gt; Δt = 1.0;

julia&gt; t = 0.0;

julia&gt; u = deepcopy(u₀);</code></pre><p>Now we can construct the integrator. We supply examples for the state <code>u</code> and the Lagrange multiplier data <code>f</code>, the time-step size, the constructor for the integrating factor, a tuple of the operators for computing the actions of <span>$B_1^T$</span> and <span>$B_2$</span> on data of type <code>f</code> and <code>u</code>, respectively (which, in this case, are matrices <code>Hmat</code> and <code>Emat</code>), and a tuple of the right-hand side functions.</p><pre><code class="language-julia-repl">julia&gt; ifherk = IFHERK(u,f,Δt,plan_intfact,(Hmat,Emat),(r₁,r₂),rk=TimeMarching.Euler)
ERROR: MethodError: objects of type Tuple{Whirl.Fields.RegularizationMatrix{Whirl.Fields.Nodes{Whirl.Fields.Dual,129,129},Whirl.Fields.ScalarData{128}},Whirl.Fields.InterpolationMatrix{Whirl.Fields.Nodes{Whirl.Fields.Dual,129,129},Whirl.Fields.ScalarData{128}}} are not callable</code></pre><p>Here we&#39;ve set the method to forward Euler. The resulting integrator accepts as arguments the current time <code>t</code> and the current state <code>u</code>, and returns the time, state, and Lagrange multiplier data at the end of the time step.</p><p>Now, let&#39;s advance the system. We&#39;ll time it, too, to see how long it takes to advance 20 steps.</p><pre><code class="language-julia-repl">julia&gt; @time for i = 1:20
         t, u, f = ifherk(t,u)
       end
ERROR: UndefVarError: ifherk not defined</code></pre><p>Now let&#39;s plot it</p><pre><code class="language-julia-repl">julia&gt; xg, yg = coordinates(u,dx=Δx);

julia&gt; plot(xg,yg,u)
Plot{Plots.PyPlotBackend() n=1}

julia&gt; plot!(xb,yb,linecolor=:black,linewidth=1.5)
Plot{Plots.PyPlotBackend() n=2}</code></pre><p><img src="ifherk.svg" alt/></p><p>From a side view, we can see that it enforces the boundary condition:</p><pre><code class="language-julia-repl">julia&gt; plot(xg,u[65,:],xlabel=&quot;x&quot;,ylabel=&quot;u(x,1)&quot;)
Plot{Plots.PyPlotBackend() n=1}</code></pre><p><img src="ifherk-side.svg" alt/></p><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Whirl.TimeMarching.IFHERK" href="#Whirl.TimeMarching.IFHERK"><code>Whirl.TimeMarching.IFHERK</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">IFHERK(u,f,Δt,plan_intfact,B₁ᵀ,B₂,r₁,r₂;[tol=1e-3],[issymmetric=false],[rk::RKParams=RK31])</code></pre><p>Construct an integrator to advance a system of the form</p><p>du/dt - Au = -B₁ᵀf + r₁(u,t) B₂u = r₂(u,t)</p><p>The resulting integrator will advance the system <code>(u,f)</code> by one time step, <code>Δt</code>. The optional argument <code>tol</code> sets the tolerance of iterative saddle-point solution, if applicable.</p><p><strong>Arguments</strong></p><ul><li><p><code>u</code> : example of state vector data</p></li><li><p><code>f</code> : example of constraint force vector data</p></li><li><p><code>Δt</code> : time-step size</p></li><li><p><code>plan_intfact</code> : constructor to set up integrating factor operator for <code>A</code> that             will act on type <code>u</code> (by left multiplication) and return same type as <code>u</code></p></li><li><p><code>plan_constraints</code> : constructor to set up the</p></li><li><p><code>B₁ᵀ</code> : operator acting on type <code>f</code> and returning type <code>u</code></p></li><li><p><code>B₂</code> : operator acting on type <code>u</code> and returning type <code>f</code></p></li><li><p><code>r₁</code> : operator acting on type <code>u</code> and <code>t</code> and returning <code>u</code></p></li><li><p><code>r₂</code> : operator acting on type <code>u</code> and <code>t</code> and returning type <code>f</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/Whirl.jl/blob/885dee7bf6f0aa99ed326765974485804cb18aec/src/timemarching/ifherk.jl#L3-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Whirl.TimeMarching.IFRK" href="#Whirl.TimeMarching.IFRK"><code>Whirl.TimeMarching.IFRK</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">IFRK(u,Δt,plan_intfact,r₁;[rk::RKParams=RK31])</code></pre><p>Construct an integrator to advance a system of the form</p><p>du/dt - Au = r₁(u,t)</p><p>The resulting integrator will advance the state <code>u</code> by one time step, <code>Δt</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>u</code> : example of state vector data</p></li><li><p><code>Δt</code> : time-step size</p></li><li><p><code>plan_intfact</code> : constructor to set up integrating factor operator for <code>A</code> that             will act on type <code>u</code> (by left multiplication) and return same type as <code>u</code></p></li><li><p><code>r₁</code> : operator acting on type <code>u</code> and <code>t</code> and returning <code>u</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/Whirl.jl/blob/885dee7bf6f0aa99ed326765974485804cb18aec/src/timemarching/ifrk.jl#L3-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Whirl.TimeMarching.RK" href="#Whirl.TimeMarching.RK"><code>Whirl.TimeMarching.RK</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RK(u,Δt,r₁;[rk::RKParams=RK31])</code></pre><p>Construct an integrator to advance a system of the form</p><p>du/dt = r₁(u,t)</p><p>The resulting integrator will advance the state <code>u</code> by one time step, <code>Δt</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>u</code> : example of state vector data</p></li><li><p><code>Δt</code> : time-step size</p></li><li><p><code>r₁</code> : operator acting on type <code>u</code> and <code>t</code> and returning <code>u</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/Whirl.jl/blob/885dee7bf6f0aa99ed326765974485804cb18aec/src/timemarching/rk.jl#L3-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Whirl.TimeMarching.System" href="#Whirl.TimeMarching.System"><code>Whirl.TimeMarching.System</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Abstract type for a system of ODEs</p></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/Whirl.jl/blob/885dee7bf6f0aa99ed326765974485804cb18aec/src/TimeMarching.jl#L8">source</a></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="timemarching.html#Whirl.TimeMarching.IFHERK"><code>Whirl.TimeMarching.IFHERK</code></a></li><li><a href="timemarching.html#Whirl.TimeMarching.IFRK"><code>Whirl.TimeMarching.IFRK</code></a></li><li><a href="timemarching.html#Whirl.TimeMarching.RK"><code>Whirl.TimeMarching.RK</code></a></li><li><a href="timemarching.html#Whirl.TimeMarching.System"><code>Whirl.TimeMarching.System</code></a></li></ul><footer><hr/><a class="previous" href="saddlesystems.html"><span class="direction">Previous</span><span class="title">Saddle point systems</span></a></footer></article></body></html>
