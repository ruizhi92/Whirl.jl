<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Saddle point systems · Whirl.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Whirl.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="fields.html">Fields</a></li><li><a class="toctext" href="bodies.html">Bodies</a></li><li class="current"><a class="toctext" href="saddlesystems.html">Saddle point systems</a><ul class="internal"><li><a class="toctext" href="#Translating-cylinder-in-potential-flow-1">Translating cylinder in potential flow</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li><li><a class="toctext" href="timemarching.html">Time marching</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="saddlesystems.html">Saddle point systems</a></li></ul><a class="edit-page" href="https://github.com/jdeldre/Whirl.jl/blob/master/docs/src/manual/saddlesystems.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Saddle point systems</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Saddle-point-systems-1" href="#Saddle-point-systems-1">Saddle point systems</a></h1><div>\[\def\ddt#1{\frac{\mathrm{d}#1}{\mathrm{d}t}}

\renewcommand{\vec}{\boldsymbol}
\newcommand{\uvec}[1]{\vec{\hat{#1}}}
\newcommand{\utangent}{\uvec{\tau}}
\newcommand{\unormal}{\uvec{n}}

\renewcommand{\d}{\,\mathrm{d}}\]</div><div></div><p>Saddle systems comprise an important part of solving mechanics problems with constraints. In such problems, there is an underlying system to solve, and the addition of constraints requires that the system is subjected to additional forces (constraint forces, or Lagrange multipliers) that enforce these constraints in the system. Examples of such constrained systems are the divergence-free velocity constraint in incompressible flow (for which pressure is the associated Lagrange multiplier field), the no-slip and/or no-flow-through condition in general fluid systems adjacent to impenetrable bodies, and joint constraints in rigid-body mechanics.</p><p>A general saddle-point system has the form</p><div>\[\left[ \begin{array}{cc} A &amp; B_1^T \\ B_2 &amp; 0\end{array}\right] \left(\begin{array}{c}u\\f \end{array}\right) = \left(\begin{array}{c}r_1\\r_2 \end{array}\right)\]</div><p>We are primarily interested in cases when the operator <span>$A$</span> is symmetric and positive definite, which is fairly typical. It is also fairly common for <span>$B_1 = B_2$</span>, so that the whole system is symmetric.</p><p><code>whirl</code> allows us to solve such systems for <span>$u$</span> and <span>$f$</span> in a fairly easy way. We need only to provide rules for how to evaluate the actions of the various operators in the system. Let us use an example to show how this can be done.</p><h2><a class="nav-anchor" id="Translating-cylinder-in-potential-flow-1" href="#Translating-cylinder-in-potential-flow-1">Translating cylinder in potential flow</a></h2><p>In irrotational, incompressible flow, the streamfunction <span>$\psi$</span> satisfies Laplace&#39;s equation,</p><div>\[\nabla^2 \psi = 0\]</div><p>On the surface of an impenetrable body, the streamfunction must obey the constraint</p><div>\[\psi = \psi_b\]</div><p>where <span>$\psi_b$</span> is the streamfunction associated with the body&#39;s motion. Let us suppose the body is moving vertically with velocity 1. Then <span>$\psi_b = -x$</span> for all points inside or on the surface of the body. Thus, the streamfunction field outside this body is governed by Laplace&#39;s equation subject to the constraint.</p><p>Let us solve this problem on a staggered grid, using the tools discussed in the Fields section, including the regularization and interpolation methods to immerse the body shape on the grid. Then our saddle-point system has the form</p><div>\[\left[ \begin{array}{cc} L &amp; H \\ E &amp; 0\end{array}\right] \left(\begin{array}{c}\psi\\f \end{array}\right) = \left(\begin{array}{c}0\\\psi_b \end{array}\right)\]</div><p>where <span>$L$</span> is the discrete Laplacian, <span>$H$</span> is the regularization operator, and <span>$E$</span> is the interpolation operator.</p><p>Physically, <span>$f$</span> isn&#39;t really a force here, but rather, represents the strengths of distributed singularities on the surface. In fact, this strength represents the jump in normal derivative of <span>$\psi$</span> across the surface. Since this normal derivative is equivalent to the tangential velocity, <span>$f$</span> is the strength of the bound vortex sheet on the surface. This will be useful to know when we check the value of <span>$f$</span> obtained in our solution.</p><p>First, let us set up the body, centered at <span>$(1,1)$</span> and of radius <span>$1/2$</span>. We will also initialize a data structure for the force:</p><div></div><pre><code class="language-julia-repl">julia&gt; n = 128; θ = linspace(0,2π,n+1);

julia&gt; xb = 1.0 + 0.5*cos.(θ[1:n]); yb = 1.0 + 0.5*sin.(θ[1:n]);

julia&gt; X = VectorData(xb,yb);

julia&gt; f = ScalarData(X);</code></pre><p>Now let&#39;s set up a grid of size <span>$102\times 102$</span> (including the usual layer of ghost cells) and physical dimensions <span>$2\times 2$</span>.</p><pre><code class="language-julia-repl">julia&gt; nx = 102; ny = 102; Lx = 2.0; dx = Lx/(nx-2);

julia&gt; w = Nodes(Dual,(nx,ny));</code></pre><p>We need to set up the operators now. First, the Laplacian:</p><pre><code class="language-julia-repl">julia&gt; L = plan_laplacian(size(w),with_inverse=true)
Discrete Laplacian (and inverse) on a (nx = 102, ny = 102) grid with spacing 1.0

julia&gt; L⁻¹(w::T) where {T} = L\w
L⁻¹ (generic function with 1 method)</code></pre><p>The last line just defines another operator for computing the inverse of <span>$L$</span>. We have called it <code>L⁻¹</code> for useful shorthand. This operator acts upon dual nodal data and returns data of the same type, e.g. <code>ψ = L⁻¹(w)</code>. The saddle point system structure requires operators that have this sort of form.</p><p>Now we need to set up the regularization <code>H</code> and interpolation <code>E</code> operators.</p><pre><code class="language-julia-repl">julia&gt; regop = Regularize(X,dx;issymmetric=true)
Symmetric regularization/interpolation operator with non-filtered interpolation
  128 points in grid with cell area 0.0004

julia&gt; Hmat, Emat = RegularizationMatrix(regop,f,w);</code></pre><p>Now we are ready to set up the system.</p><pre><code class="language-julia-repl">julia&gt; S = SaddleSystem((w,f),(L⁻¹,Hmat,Emat),issymmetric=true,isposdef=true)
Saddle system with 128 constraints and
   State of type Whirl.Fields.Nodes{Whirl.Fields.Dual,102,102}
   Force of type Whirl.Fields.ScalarData{128}</code></pre><p>Note that we have provided a tuple of the types of data, <code>w</code> and <code>f</code>, that we want the solver to work with, along with a tuple of the definitions of the three operators. The operators can be in the form of a function acting on its data (as for <code>L⁻¹</code>) or in the form of a matrix (or matrix-like) operator (as for <code>Hmat</code> and <code>Emat</code>); the constructor sorts it out. However, the order is important: we must supply <span>$A^{-1}$</span>, <span>$B_1^T$</span>, and <span>$B_2$</span>, in that order.</p><p>We have also set two optional flags, to specify that the system is symmetric and positive definite. This instructs on which solver to use. (This is actually not quite true for the Laplacian: it is only positive semi-definite, since this operator has a null space. It is   adequate criteria for using the conjugate gradient method, but we will have to   be careful of some aspects of the solution, we we will see below.)</p><p>Let&#39;s solve the system. We need to supply the right-hand side.</p><pre><code class="language-julia-repl">julia&gt; w = Nodes(Dual,(nx,ny));

julia&gt; ψb = ScalarData(X);

julia&gt; ψb .= -(xb-1);</code></pre><p>The right-hand side of the Laplace equation is zero. The right-hand side of the constraint is the specified streamfunction on the body. Note that we have subtracted the circle center from the <span>$x$</span> positions on the body. The reason for this will be discussed in a moment.</p><p>We solve the system with the convenient shorthand of the backslash:</p><pre><code class="language-julia-repl">julia&gt; @time ψ,f = S\(w,ψb)
  0.125350 seconds (78.89 k allocations: 4.361 MiB)
(Whirl.Fields.Dual nodes in a (nx = 102, ny = 102) cell grid
  Number of Whirl.Fields.Dual nodes: (nx = 102, ny = 102), 128 points of scalar-valued data
)</code></pre><p>Just to point out how fast it can be, we have also timed it. It&#39;s pretty fast.</p><p>Now, let&#39;s plot the solution in physical space. We&#39;ll plot the body shape for reference, also.</p><pre><code class="language-julia-repl">julia&gt; xg, yg = coordinates(ψ,dx=dx)
(-0.01:0.02:2.0100000000000002, -0.01:0.02:2.0100000000000002)

julia&gt; plot(xg,yg,ψ)
Plot{Plots.PyPlotBackend() n=1}

julia&gt; plot!(xb,yb,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black)
Plot{Plots.PyPlotBackend() n=2}</code></pre><p><img src="sfunc.svg" alt/></p><p>The solution shows the streamlines for a circle in vertical motion, as expected. All of the streamlines inside the circle are vertical.</p><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Type-Union{Tuple{FA}, Tuple{FB1}, Tuple{FB2}, Tuple{FP}, Tuple{TF}, Tuple{TU}, Tuple{Tuple{TU,TF},Tuple{FA,FB1,FB2}}} where FP where FB2 where FB1 where FA where TF where TU" href="#Core.Type-Union{Tuple{FA}, Tuple{FB1}, Tuple{FB2}, Tuple{FP}, Tuple{TF}, Tuple{TU}, Tuple{Tuple{TU,TF},Tuple{FA,FB1,FB2}}} where FP where FB2 where FB1 where FA where TF where TU"><code>Core.Type</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SaddleSystem((u,f),(A⁻¹,B₁ᵀ,B₂);[tol=1e-3],[issymmetric=false],[isposdef=false],[conditioner=Identity],[store=false])</code></pre><p>Construct the computational operators for a saddle-point system of the form <span>$[A B₁ᵀ; B₂ 0][u;f]$</span>. Note that the constituent operators are passed in as a tuple in the order seen here. Each of these operators could act on its corresponding data type in a function-like way, e.g. <code>A⁻¹(u)</code>, or in a matrix-like way, e.g., <code>A⁻¹*u</code>.</p><p>The optional argument <code>tol</code> sets the tolerance for iterative solution (if   applicable). Its default is 1e-3.</p><p>The optional argument <code>conditioner</code> can be used to supply a function that acts upon the result <code>f</code> to &#39;condition&#39; it (e.g. filter it). It is, by default, set to the identity.</p><p>The optional Boolean argument <code>store</code> will compute and store the Schur complement matrix&#39;s factorization. This makes the inversion faster, though it comes at the expense of memory and overhead time for pre-computing it. The resulting solution is somewhat noiser, too.</p><p><strong>Arguments</strong></p><ul><li><p><code>u</code> : example of state vector data.</p></li><li><p><code>f</code> : example of constraint force vector data. This data must be of       AbstractVector supertype.</p></li><li><p><code>A⁻¹</code> : operator evaluating the inverse of <code>A</code> on data of type <code>u</code>, return type <code>u</code></p></li><li><p><code>B₁ᵀ</code> : operator evaluating the influence of constraint force,           acting on <code>f</code> and returning type <code>u</code></p></li><li><p><code>B₂</code> : operator evaluating the influence of state vector on constraints,           acting on <code>u</code> and returning type <code>f</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/Whirl.jl/blob/885dee7bf6f0aa99ed326765974485804cb18aec/src/SaddlePointSystems.jl#L27-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.A_ldiv_B!-Union{Tuple{FAB}, Tuple{FA}, Tuple{FBA}, Tuple{FP}, Tuple{N}, Tuple{TF}, Tuple{TU}, Tuple{Tuple{TU,TF},Whirl.SaddlePointSystems.SaddleSystem{FA,FAB,FBA,FP,TU,TF,N,false},Tuple{TU,TF}}} where N where FP where FBA where FAB where FA where TF where TU" href="#Base.LinAlg.A_ldiv_B!-Union{Tuple{FAB}, Tuple{FA}, Tuple{FBA}, Tuple{FP}, Tuple{N}, Tuple{TF}, Tuple{TU}, Tuple{Tuple{TU,TF},Whirl.SaddlePointSystems.SaddleSystem{FA,FAB,FBA,FP,TU,TF,N,false},Tuple{TU,TF}}} where N where FP where FBA where FAB where FA where TF where TU"><code>Base.LinAlg.A_ldiv_B!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">A_ldiv_B!(state,sys::SaddleSystem,rhs)</code></pre><p>Solve a saddle-point system. <code>rhs</code> is a tuple of the right-hand side <code>(ru,rf)</code>. Output <code>state</code>, a tuple (u,f), is updated. Note that <code>sys</code> is also mutated: its scratch space <code>sys.B₂A⁻¹r₁</code> and <code>sys.A⁻¹B₁ᵀf</code> hold the intermediate results of the solution.</p><p>A shorthand can be used for this operation: <code>state = sys hs</code></p></div><a class="source-link" target="_blank" href="https://github.com/jdeldre/Whirl.jl/blob/885dee7bf6f0aa99ed326765974485804cb18aec/src/SaddlePointSystems.jl#L142-L151">source</a></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="saddlesystems.html#Core.Type-Union{Tuple{FA}, Tuple{FB1}, Tuple{FB2}, Tuple{FP}, Tuple{TF}, Tuple{TU}, Tuple{Tuple{TU,TF},Tuple{FA,FB1,FB2}}} where FP where FB2 where FB1 where FA where TF where TU"><code>Core.Type</code></a></li><li><a href="saddlesystems.html#Base.LinAlg.A_ldiv_B!-Union{Tuple{FAB}, Tuple{FA}, Tuple{FBA}, Tuple{FP}, Tuple{N}, Tuple{TF}, Tuple{TU}, Tuple{Tuple{TU,TF},Whirl.SaddlePointSystems.SaddleSystem{FA,FAB,FBA,FP,TU,TF,N,false},Tuple{TU,TF}}} where N where FP where FBA where FAB where FA where TF where TU"><code>Base.LinAlg.A_ldiv_B!</code></a></li></ul><footer><hr/><a class="previous" href="bodies.html"><span class="direction">Previous</span><span class="title">Bodies</span></a><a class="next" href="timemarching.html"><span class="direction">Next</span><span class="title">Time marching</span></a></footer></article></body></html>
